<template lang="pug">
  #app.theme-transition(:class="`${theme}-theme`")
    app-header.app-header(
      v-if="showMenuBar"
    )
    div.d-flex.app-page
      sidebar-menu
      router-view.flex-1
    update-popup(v-if="isElectron") 
    the-info-popup(v-if="showPopup")
    confirm-popup
    delete-confirm-popup
    PiPyPopupUpdate(v-if="showPiPyNotification")
    create-issue-popup(v-if="showCreateIssuesPopup")
    modal-pages-engine
    tutorials-checklist(:style="tutorialChecklistPosition")
    about-app-popup(v-if="showAppAboutPopUp")
    file-picker-popup(
      v-if="showFilePickerPopup"
      :filePickerType="showFilePickerPopup.filePickerType"
      :fileTypeFilter="showFilePickerPopup.fileTypeFilter"
      :popupTitle="showFilePickerPopup.popupTitle"
      :confirmCallback="showFilePickerPopup.confirmCallback || showFilePickerPopup"
      :options="showFilePickerPopup.options")
    add-card-popup(v-if="showAddCardPopup")
    #tutorial-notifications(v-if="showTutorialNotifications")
      tutorial-notification(
        v-for="n in tutorialNotifications"
        :key="n.stepCode"
        :stepCode="n.stepCode"
        :arrowDirection="n.arrowDirection"
      )
</template>

<script>
  import { isWeb, isElectron, isOsMacintosh, isBrowserChromeOrFirefox} from "@/core/helpers";
  import CreateIssuePopup         from '@/components/global-popups/create-issues-popup.vue';
  import TutorialsChecklist       from '@/components/tutorial/tutorial-checklist.vue';
  import TutorialNotification from "@/components/different/tutorial-notification.vue";
  import { 
    getModelJson as rygg_getModelJson,
    createDataset as rygg_createDataset,
    attachModelsToDataset as rygg_attachModelsToDataset,
  } from '@/core/apiRygg';
  import { ryggAvailability } from '@/core/apiRygg';
  import Analytics from '@/core/analytics';
  import { LOCAL_STORAGE_WORKSPACE_VIEW_TYPE_KEY, localStorageGridKey, THEME_LIGHT, THEME_DARK } from '@/core/constants.js'
  import { mapMutations, mapActions, mapGetters, mapState } from 'vuex';
  import { getModelDatasetPath } from '@/core/modelHelpers.js';
  import SidebarMenu            from '@/pages/layout/sidebar-menu.vue';
  import AppHeader              from '@/components/app-header/app-header.vue';
  import UpdatePopup            from '@/components/global-popups/update-popup/update-popup.vue'
  import PiPyPopupUpdate        from "@/components/global-popups/update-popup/pipy-update-popup.vue";  
  import TheInfoPopup           from "@/components/global-popups/the-info-popup.vue";
  import ConfirmPopup           from "@/components/global-popups/confirm-popup.vue";
  import DeleteConfirmPopup     from "@/components/global-popups/delete-confirm-popup.vue";
  import ModalPagesEngine       from '@/components/modal-pages-engine.vue';
  import AboutAppPopup          from "@/components/global-popups/about-app-popup.vue";
  import FilePickerPopup        from "@/components/global-popups/file-picker-popup.vue";
  import AddCardPopup           from "@/components/global-popups/add-card-popup.vue";
  import { MODAL_PAGE_PROJECT, MODAL_PAGE_QUESTIONNAIRE } from '@/core/constants.js';
  import { isUrlReachable, isEnterpriseApp } from '@/core/apiRygg.js';
  import { keyCloak } from '@/core/apiKeyCloak.js';
  

  export default {
    name: 'TheApp',
    components: {
      SidebarMenu,
      ModalPagesEngine,
      // HeaderLinux, HeaderWin, HeaderMac,
      UpdatePopup, TheInfoPopup, ConfirmPopup, DeleteConfirmPopup, CreateIssuePopup, PiPyPopupUpdate, AboutAppPopup, FilePickerPopup, AddCardPopup,
      AppHeader,
      TutorialsChecklist, TutorialNotification
    },
    beforeCreate() {
      this.$store.dispatch('mod_api/API_setAppInstance');
    },
    async created() {
      if(!isBrowserChromeOrFirefox()) {
        this.$store.dispatch('globalView/GP_infoPopup', 'PerceptiLabs works best in FireFox and Chrome, we suggest you use the tool there instead for the best experience.'); 
      }
      window.addEventListener("beforeunload", (e) => {
        let networksHaveChanges = this.networksWithChanges.some(id=> this.getWorkspacesIds.includes(id));
        if(networksHaveChanges) { 
          const confirmationMessage = 'It looks like you have edited model.';
          
          (e || window.event).returnValue = confirmationMessage; //Gecko + IE

          return confirmationMessage; //Gecko + Webkit, Safari, Chrome etc.
        }
    });
      window.addEventListener('online',  this.updateOnlineStatus);
      window.addEventListener('offline', this.updateOnlineStatus);
      this.trackerInit();
      this.readUserInfo();
      this.checkRyggAvailability();
      
      this.$store.commit('mod_project/setIsDefaultProjectMode');
      await isEnterpriseApp()
        .then(isEnterpriseAppValue => {
          return this.$store.commit('globalView/set_isEnterpriseApp', isEnterpriseAppValue);
        });
      await this.$store.dispatch('mod_datasets/getDatasets');
    },
    mounted() {
      this.$intercom.boot({
        hide_default_launcher: true
      });

      this.getPyPiUpdate();

      if (this.isDefaultProjectMode) { 
        // in the free version, the user is locked to a single project
        this.getDefaultModeProject().then((defaultProject) => {
          this.fetchNetworkMetas(defaultProject);
        });
      }
      else if(localStorage.hasOwnProperty('targetProject')) {
        const targetProjectId = parseInt(localStorage.getItem('targetProject'));
        
        // this.loadProjectFromLocalStorage(targetProjectId)
        this.getProjects()
          .then(({data: { results: projects }}) => {
            if(targetProjectId) {
              const targetProject = projects.find(project => project.project_id === targetProjectId);
              if (targetProject) {
                console.log('targetProject', targetProject);
                this.fetchNetworkMetas(targetProject);
              }
              // this.reset_network();
            }
          })
      } else {
        this.getProjects();
        if(localStorage.hasOwnProperty('currentUser')) {
          this.setActivePageAction(MODAL_PAGE_PROJECT);
        }
      }
      if(localStorage.hasOwnProperty(localStorageGridKey)) {
        const gridValue = localStorage.getItem(localStorageGridKey) === 'true';
        this.$store.commit('globalView/setGridStateMutation', gridValue);
      }      
      
      this.$store.commit('mod_workspace-changes/get_workspaceChangesInLocalStorage');

      this.$store.dispatch('mod_tutorials/loadTutorialProgress')
        .then(async () => {
          if (this.isUserFirstLogin) {
            // if (!process.env.NO_KC && keyCloak.isReachable()){
              // this.setActivePageAction(MODAL_PAGE_QUESTIONNAIRE);
            // }

          } else if (!this.getHasShownWhatsNew) {
            // this.setActivePageAction(MODAL_PAGE_WHATS_NEW);
          } else {
            this.initTutorialView();
          }
        });      

      this.$store.dispatch('mod_tutorials/activateNotification');
      this.$store.dispatch('mod_api/checkCoreVersions', null, {root: true});

      this.updateOnlineStatus();
      this.SET_appVersion(process.env.PACKAGE_VERSION);
      this.$store.dispatch('mod_api/API_runServer', null, {root: true});
      // document.body.style.overflow = 'hidden';
      document.addEventListener('keydown', this.disableHotKeys);
     
      // this.$store.dispatch('mod_workspace/GET_workspacesFromLocalStorage');

      if(!this.user) this.cloud_userGetProfile();

      setTimeout(() => {
        this.$store.dispatch('mod_api/API_getOutputDim');
      }, 1000);
    },
    beforeDestroy() {
      window.removeEventListener('online',  this.updateOnlineStatus);
      window.removeEventListener('offline', this.updateOnlineStatus);
      document.removeEventListener('keydown', this.disableHotKeys);
    },
    data() {
      return {
        showMacHeader: true,
        isWeb: isWeb(),
        isElectron: isElectron(),
      }
    },
    computed: {
      ...mapState({
        showFilePickerPopup:        state => state.globalView.globalPopup.showFilePickerPopup,
        theme:                      state => state.globalView.theme
      }),
      ...mapGetters({
        user:                   'mod_user/GET_userProfile',
        email:                  'mod_user/GET_userEmail',
        isDefaultProjectMode:   'mod_project/GET_isDefaultProjectMode',
        currentProject:         'mod_project/GET_project',
        viewType:               'mod_workspace/GET_viewType',
        currentModelIndex:      'mod_workspace/GET_currentModelIndex',
        currentStatsIndex:      'mod_workspace/GET_currentStatsIndex',
        currentTestIndex:       'mod_workspace/GET_currentTestIndex',
        networksWithChanges:    'mod_workspace-changes/get_networksWithChanges',
        showPiPyNotification:   'mod_workspace-notifications/getPiPyShowNotification',
        getActiveNotifications: 'mod_tutorials/getActiveNotifications',
        getIsTutorialMode:      'mod_tutorials/getIsTutorialMode',
        getShowChecklist:       'mod_tutorials/getShowChecklist',
        getShowTutorialTips:    'mod_tutorials/getShowTutorialTips',
        getHasShownWhatsNew:    'mod_tutorials/getHasShownWhatsNew', 
        emptyNavigationMode:    'mod_empty-navigation/getEmptyScreenMode',
        allModelsDatasets:      'mod_datasets/GET_datasets',
      }),
      workspaceContent() {
        return this.$store.state['mod_workspace'].workspaceContent;
      },
      showNotAvailable() {
        return this.$store.state.mod_autoUpdate.showNotAvailable
      },
      showNewModelPopup() {
        return this.$store.state.globalView.globalPopup.showNewModelPopup;
      },
      userId() {
        return this.$store.getters['mod_user/GET_userID']
      },
      userProfile() {
        return this.$store.getters['mod_user/GET_userProfile']
      },
      isUserFirstLogin() {
        return this.$store.getters['mod_user/GET_isUserFirstLogin'];
      },
      /*show popup*/
      infoPopup() {
        return this.$store.state.globalView.globalPopup.showInfoPopup
      },
      errorPopup() {
        return this.$store.state.globalView.globalPopup.showErrorPopup
      },
      showPopup() {
        return this.errorPopup.length || (this.infoPopup && this.infoPopup.length);
      },      
      showMenuBar() {
        const GET_userIsLogin = this.$store.getters['mod_user/GET_userIsLogin']
        return GET_userIsLogin && ['home', 'app', 'projects', 'main-page', 'settings', 'test', 'export', 'pricing'].includes(this.$route.name);
      },
      showCreateIssuesPopup() {
        return this.$store.state.globalView.globalPopup.showCreateIssuesPopup;
      },
      currentPage() {
        return this.$store.state.modal_pages.currentPage
      },
      showTutorialChecklist() {
        if (!this.getIsTutorialMode) { return false; }
        if (!this.getShowChecklist) { return false; }
        
        if (this.hasModalsOpenInWorkspace) { return false; }

        if (!this.currentPage) {
          return true;
        }
        if (this.currentPage === 'MODAL_PAGE_PROJECT') {
          return true;
        }

        return false;
      },
      showTutorialNotifications() {
        // Don't show notifications if there are any overlays

        if (this.currentPage) { return false; }
        if (this.hasModalsOpenInWorkspace) { return false; }

        if (!this.$store.state.globalView.globalPopup.showNewModelPopup) {
          // have check each screen because the proposal to separate each view
          // into it's own component wasn't well received.
          if (this.$route.name === 'projects') { return this.getShowTutorialTips; }
          else if (this.viewType === 'model' && this.currentModelIndex === -1) { return false; }
          else if (this.viewType === 'statistic' && this.currentStatsIndex === -1) { return false; }
          else if (this.viewType === 'test' && this.currentTestIndex === -1) { return false; }
        }

        return this.getIsTutorialMode && this.getShowTutorialTips;
      },
      hasModalsOpenInWorkspace() {
        return (
          this.$store.state.globalView.globalPopup.showNetResult ||
          this.$store.state.globalView.globalPopup.showWorkspaceBeforeImport ||
          this.$store.state.globalView.globalPopup.showCoreSideSettings ||
          this.$store.state.globalView.globalPopup.showFilePickerPopup ||
          this.$store.state.globalView.globalPopup.showLoadSettingPopup ||
          this.$store.state.globalView.globalPopup.showSaveNetworkPopup ||
          this.$store.state.globalView.globalPopup.showExportNetworkToGitHubPopup ||
          this.$store.state.globalView.globalPopup.showImportNetworkfromGitHubOrLocalPopup ||
          this.showCreateIssuesPopup ||
          this.showPopup
        );

      },
      currentNetworkId() {
        return this.$store.getters['mod_workspace/GET_currentNetworkId'];
      },
      unparsedModels() {
        return this.$store.state.mod_workspace.unparsedModels
          .map(m => m.model_id);
      },
      tutorialNotifications() {
        return this.getActiveNotifications;
      },
      tutorialChecklistPosition() {

        let rightValueRm = 1;
        let bottomValueRm = 1;

        if (this.$route.name !== 'projects' &&
            this.$route.name !== 'settings' &&
            this.emptyNavigationMode === 0 &&
            !this.showNewModelPopup) {
          
          bottomValueRm += 2; // the-workspace
          bottomValueRm += 1; // scrollbars

          if (this.$store.state.globalView.hideSidebar) {
            rightValueRm += 25; // hardcoded in the-sidebar.vue file
          }

          let isNotificationWindowOpen = this.$store.getters['mod_workspace-notifications/getNotificationWindowState'](this.currentNetworkId);

          if (isNotificationWindowOpen) {
            rightValueRm += 70; // hardcoded in the workspace-code-window.vue file
          }

          const toasts = this.$store.getters['mod_workspace-notifications/getToasts'](this.currentNetworkId);
          if (toasts) {
            const errorToast = toasts.find(t => t.type === 'error');
            const warningToast = toasts.find(t => t.type === 'error');

            if ((errorToast && errorToast.count) || (warningToast && errorToast.warningToast)) {
              rightValueRm += 21; // hardcoded in the the-toaster.vue file
            }
          }
        }

        return { 
          right: `${rightValueRm}rem`,
          bottom: `${bottomValueRm}rem`
        };
      },
      showAppAboutPopUp() {
        return this.$store.state.globalView.globalPopup.showAppAbout;
      },
      showAddCardPopup() {
        return this.$store.state.globalView.globalPopup.showAddCardPopup;
      },
      getWorkspacesIds() {
        return this.$store.state['mod_workspace'].workspaceContent.map(workspace => workspace.networkID.toString());
      }
    },
    watch: {
      userId(newVal) {
        Analytics.googleAnalytics.trackUserId(this.$store.getters['mod_user/GET_userID']);
      },
      userProfile(newVal) {
        if (!newVal || newVal.email === 'Guest') { return; }

        setTimeout(() => {
          this.trackerCreateUser(newVal);
          this.trackerUpdateUser(newVal);
          this.trackerInitUser(newVal);
          this.initIntercom();
        }, 5000);
      },
    },
    methods: {
      ...mapMutations({
        SET_appVersion:       'globalView/SET_appVersion',
        SET_appIsFullView:    'globalView/SET_appIsFullView',

        // loadProjectFromLocalStorage: 'mod_workspace/get_workspacesFromLocalStorage',
        // setPageTitleMutation: 'globalView/setPageTitleMutation',

        deleteNetworkById:    'mod_workspace/delete_networkById',
        setViewTypeMutation:  'mod_workspace/setViewTypeMutation'
      }),
      ...mapActions({
        openErrorPopup:         'globalView/GP_infoPopup',
        SET_onlineStatus:       'globalView/SET_onlineStatus',

        trackerInit:            'mod_tracker/TRACK_initMixPanel',
        trackerInitUser:        'mod_tracker/TRACK_initMixPanelUser',
        trackerCreateUser:      'mod_tracker/TRACK_createUser',
        trackerUpdateUser:      'mod_tracker/TRACK_updateUser',
        trackerAppStart:        'mod_tracker/EVENT_appStart',

        setUserToken:           'mod_user/SET_userToken',
        readUserInfo:           'mod_user/GET_LOCAL_userInfo',

        setActivePageAction:    'modal_pages/setActivePageAction',

        getProjects :           'mod_project/getProjects',
        createProject:          'mod_project/createProject',
        getDefaultModeProject:  'mod_project/getDefaultModeProject',
        getModelMeta:           'mod_project/getModel',
        
        API_getModelStatus:     'mod_api/API_getModelStatus',

        cloud_userGetProfile:   'mod_apiCloud/CloudAPI_userGetProfile',
        
        reset_network:            'mod_workspace/RESET_network',
        addNetwork:               'mod_workspace/ADD_network',
        chartRequestIfNeeded:     'mod_workspace/SET_chartsRequestsIfNeeded',
        setUnparsedModels:        'mod_workspace/SET_unparsedModels',
        setStatisticsAvailability:'mod_workspace/setStatisticsAvailability',
        setCheckpointAvailability:'mod_workspace/setCheckpointAvailability',

        getPyPiUpdate:          'mod_workspace-notifications/getPyPiUpdate',

        setCurrentView:         'mod_tutorials/setCurrentView',
      }),
      updateOnlineStatus() {
        this.SET_onlineStatus(navigator.onLine);
      },
      checkRyggAvailability() {
        ryggAvailability().then(resp => {
          if (resp === "UNAVAILABLE") {
            this.openErrorPopup("The app service isn't available");
          } else if (resp === "BAD_TOKEN") {
            this.openErrorPopup("Unable to talk to the app service. Did you use the correct token to load this page?");
          }
        })
      },
      disableHotKeys(event) {
        const isHotkey = isOsMacintosh() ? event.metaKey : event.ctrlKey;
        if (!isHotkey) { 
          return; 
        }

        switch (event.code) {
          case 'KeyS':
          case 'KeyG':
              event.preventDefault();
              event.stopPropagation();
              event.returnValue = false;
              break;
        }
      },
      async fetchNetworkMetas(currentProject) {
        if (!currentProject || !currentProject.models || !currentProject.models.length) { return; }

        const promiseArray = 
          currentProject.models
            .map(x => this.getModelMeta(x));

        Promise.all(promiseArray)
          .then(metas => {
            this.fetchUnparsedModels(metas);
            this.fetchAllNetworkJsons(metas);
          });
      },
      fetchAllNetworkJsons(modelMetas) {
        
        if (!modelMetas) { return; }

        const promiseArray = []
        const filteredMetas = modelMetas
            .filter(x => x.location)
            .filter(x => !this.networksWithChanges.includes(x.model_id));

        for (const fm of filteredMetas) {
          promiseArray.push(rygg_getModelJson(fm.location + '/model.json'));
        }
        
        // console.log('fetchAllNetworkJsons filteredMetas', filteredMetas);
        Promise.all(promiseArray)
          .then(async (models) => {  
            this.addNetworksToWorkspace(models, modelMetas);
            models.forEach(model => {
              if (model) {
                const coreStatus = model.networkMeta.coreStatus.Status;
                if (coreStatus === 'Training' || coreStatus === "Validation") {
                  this.chartRequestIfNeeded(model.networkID);
                }
                this.API_getModelStatus(model.networkID);
              }
            });

            this.$nextTick(() => {
              this.setStatisticsAvailability();
              this.setCheckpointAvailability();
            });
            return models;
          })
          .then(this.handleCreateDatasets)
          .then(this.handleAttachDatasetsToModel);
      },
      // migration for creating datasets
      async handleCreateDatasets(models) {
        const alreadyCreatedDatasetsPaths = this.allModelsDatasets.map(x => x.location);
        const notExistingDatasets = models.filter(x => (x !== null)).map(model => {
          const datasetPath = getModelDatasetPath(model);
          let ret = null;
          if(!alreadyCreatedDatasetsPaths.includes(datasetPath)) {
            ret = {
              modelId: model.apiMeta.model_id,
              datasetPath,
            };
          }
          return ret;
        }).filter(x => x !== null);

        notExistingDatasets.map(async (data) => {
          // creating datasets
          await rygg_createDataset({
            project: 1,
            name: data.datasetPath,
            location: data.datasetPath,
          });
        })
        await this.$store.dispatch('mod_datasets/getDatasets');
        return models;
      },
      // migration for attaching datasets to models
      async handleAttachDatasetsToModel(models) {
        const arrOfLocations = this.allModelsDatasets.map(x => x.location);
        await this.workspaceContent.map(async (workspaceModel) => {
          if (workspaceModel.apiMeta.datasets.length === 0) {
            const datasetPath = getModelDatasetPath(workspaceModel);
            const modelDataset = this.allModelsDatasets[arrOfLocations.indexOf(datasetPath)];
            await rygg_attachModelsToDataset(modelDataset.dataset_id, [...modelDataset.models, workspaceModel.apiMeta.model_id]);
          }
        });
      },
      async fetchUnparsedModels(modelMetas){
        let unparsedModels = [];

        modelMetas.forEach(async (model) => {
          const modelJson = await rygg_getModelJson(model.location + '/model.json');
          if(!modelJson) {
            unparsedModels.push(model);
            
            // Doing these removes explicitly because the data can be loaded from webstorage
            // The effect is that the same network can appear doubled in the Model Hub
            // Remove from workspace content
            this.deleteNetworkById(model.model_id);
          }
        });

        this.setUnparsedModels({unparsedModels});
      },
      addNetworksToWorkspace(models, modelsApiData) {
        for(const [index, model] of models.entries()) {
          if(model) { 
            if (this.unparsedModels.includes(model.networkID)) { return; }

            // update apiMeta wiht rygg meta.
            model.apiMeta = modelsApiData[index];

            const matchingApiData = modelsApiData.find(mad => mad.model_id === model.networkID);
            if (matchingApiData) {
              model.networkName = matchingApiData.name;
              model.networkRootFolder = matchingApiData.location;
            }
            this.addNetwork({network: model, apiMeta: model.apiMeta, focusOnNetwork: false});

           }
        }
        
        this.$store.commit('mod_workspace/get_lastActiveTabFromLocalStorage');
      },
    
      initTutorialView() {
        const viewType = localStorage.getItem(LOCAL_STORAGE_WORKSPACE_VIEW_TYPE_KEY);

        // for the project side bar
        this.setViewTypeMutation(viewType);

        // for the tutorial
        if (this.$route.name === 'projects') { 
        } else if (viewType === 'model') {
          this.setCurrentView('tutorial-workspace-view');
        } else if (viewType === 'statistic') {
          this.setCurrentView('tutorial-statistics-view');
        } else if (viewType === 'test') {
          this.setCurrentView('tutorial-test-view');
        }
      },

      initIntercom() {
        this.$intercom.update({
          name: this.email,
          email: this.email,
        });
      }
    },
  }
</script>

<style lang="scss">
  @import "scss/global";
  #app {
    height: 100vh;
    display: grid;
    grid-template-areas: 'header' 'page';
    grid-template-rows: auto 1fr;
    grid-template-columns: 1fr;
    overflow: hidden;
    background: $bg-window;
    position: relative;
  }
  .app-header {
    position: relative;
    z-index: 13;
    grid-area: header;
    -webkit-app-region: drag;
    .btn {
      -webkit-app-region: no-drag;
    }
  }
  .app-page {
    grid-area: page;
    overflow: hidden;
  }
  
  .flex-1 {
    flex: 1;
    
    background-color: theme-var($neutral-7);
    border-radius: 15px 0px 0px 0px;
  }
</style>
