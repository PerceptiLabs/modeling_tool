{% macro layer_dataenvironment(layer_spec, graph_spec=None) %}
class {{layer_spec.sanitized_name}}(DataReinforce):
    """Class responsible for running the gym environment."""    
    def __init__(self):
        self._variables = {}
        self._env_name = '{{layer_spec.environment_name}}'
        self._env = gym.make(self._env_name)
        sample = self._env.reset()
        action_space = self._env.action_space.n
        
        self._variables = {k: v for k, v in locals().items() if can_serialize(v)}

    @property
    def variables(self) -> Dict[str, Picklable]:
        """Returns any variables that the layer should make available and that can be pickled."""
        return self._variables

    @property
    def sample(self) -> np.ndarray:
        """Returns the new state of the environment after taking a random step"""                    
        gen = (self.make_generator())
        next(gen)
        sample = gen.send(None)
        return sample

    @property
    def action_space(self) -> List[int]:
        """ Returns the action space of the environment"""
        n_actions = self._env.action_space.n
        return list(range(0,n_actions))
        

    def make_generator(self) -> Generator[np.ndarray, None, None]:
        """Returns a sample from gym environment."""                                        
        def gen():
            env = gym.make(self._env_name)
            start_state = env.reset()
            while True:
                action = yield
                if not action:
                    action = env.action_space.sample()
                    [new_state, reward, done, info] = env.step(action)
                elif action == 'reset':
                    new_state, reward, done, info = env.reset(), None, False, {}
                else:
                    [new_state, reward, done, info] = env.step(action)
                    
                state_info = {'output': new_state, 'reward': reward, 'done': done, 'info': info}
                yield state_info
        return gen()

    def reset_environment(self, generator) -> np.ndarray:
        """ resets the environment"""
        state = generator.send('reset')
        next(generator)
        return state

    def take_action(self, generator, action) -> List:
        """ takes a step in the current environment given action and returns the new state information"""
        if action not in self.action_space:
            raise ValueError("Invalid action: valid actions are {}.".format(self.action_space))
        new_state_info = generator.send(action)
        next(generator)
        return new_state_info

{% endmacro %}
